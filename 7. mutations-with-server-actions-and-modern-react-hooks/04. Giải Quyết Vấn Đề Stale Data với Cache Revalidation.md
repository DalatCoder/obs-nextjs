## Giải Quyết Vấn Đề Stale Data với Cache Revalidation

### Vấn Đề Stale Data

**Hiện tượng xảy ra**

Sau khi cập nhật dữ liệu thành công trong [[Server Actions]], khi navigate đi rồi quay lại trang profile, dữ liệu hiển thị vẫn là dữ liệu cũ thay vì dữ liệu vừa cập nhật.

**Nguyên nhân**

- Dữ liệu được lưu trong [[Router Cache]] (Browser Cache)
- Cache cho [[Dynamic Routes]] tồn tại 30 giây
- NextJS serve dữ liệu từ cache thay vì fetch mới từ server
- Chỉ sau 30 giây hoặc hard reload mới thấy dữ liệu mới

**Ví dụ thực tế**

```
1. User cập nhật nationality từ Belgium → Brazil
2. Navigate đến trang Home
3. Quay lại Guest Profile
4. Vẫn thấy Belgium (stale data)
5. Sau 30 giây, mới thấy Brazil
```


### Hai Loại Revalidation

**Time-based Revalidation (Theo thời gian)**

- Cache tự động revalidate sau một khoảng thời gian định trước
- Phù hợp với dữ liệu ít thay đổi
- Ví dụ: revalidate mỗi 3600 giây (1 giờ)

**On-demand Revalidation (Theo yêu cầu)**

- Xóa cache và refetch dữ liệu ngay lập tức
- Được trigger thủ công khi cần
- Phù hợp khi cập nhật dữ liệu và muốn UI phản ánh ngay

Trong trường hợp này, ta cần **on-demand revalidation** vì muốn dữ liệu cập nhật ngay sau khi user submit form.

### Sử dụng revalidatePath

**Import function**

```javascript
import { revalidatePath } from 'next/cache';
```

**Thêm vào cuối Server Action**

```javascript
export async function updateGuest(formData) {
  // 1. Authentication
  const session = await auth();
  if (!session) throw new Error('You must be logged in');
  
  // 2. Get and validate data
  const nationalID = formData.get('nationalID');
  const [nationality, countryFlag] = formData.get('nationality').split('%');
  
  const regex = /^[a-zA-Z0-9]{6,12}$/;
  if (!regex.test(nationalID)) {
    throw new Error('Please provide a valid national ID');
  }
  
  // 3. Update database
  const updateData = { nationality, countryFlag, nationalID };
  const { error } = await supabase
    .from('guests')
    .update(updateData)
    .eq('id', session.user.guestID);
    
  if (error) throw new Error('Guest could not be updated');
  
  // 4. Revalidate cache - QUAN TRỌNG
  revalidatePath('/account/profile');
}
```

**Cách hoạt động**

- Xóa toàn bộ cache cho đường dẫn `/account/profile`
- Lần request tiếp theo sẽ fetch dữ liệu mới từ server
- UI tự động re-render với dữ liệu mới


### Chọn Path Revalidation Phù Hợp

**Option 1: Revalidate toàn bộ account section**

```javascript
revalidatePath('/account');
```

- Xóa cache cho tất cả routes dưới `/account`
- Bao gồm: `/account/profile`, `/account/reservations`, etc.
- **Nhược điểm:** Revalidate nhiều hơn cần thiết, lãng phí resources

**Option 2: Revalidate chỉ route cụ thể (Khuyến nghị)**

```javascript
revalidatePath('/account/profile');
```

- Chỉ xóa cache cho đường dẫn này
- **Ưu điểm:** Hiệu quả, chỉ revalidate dữ liệu thực sự thay đổi
- Phù hợp với trường hợp cập nhật profile


### Kết Quả Sau Khi Revalidate

**Hiệu ứng ngay lập tức**

- Cờ quốc gia thay đổi ngay sau khi submit
- Dữ liệu được fetch lại và component re-render
- Navigate đi rồi quay lại vẫn thấy dữ liệu mới

**So sánh trước và sau**

Trước khi có `revalidatePath`:

```
Update → Navigate away → Return → Thấy dữ liệu cũ (30s)
```

Sau khi có `revalidatePath`:

```
Update → Navigate away → Return → Thấy dữ liệu mới (ngay lập tức)
```


### Khi Nào Cần Revalidate

**Cần revalidate khi**

- Dữ liệu được cập nhật và cần hiển thị ngay trên UI
- User cần thấy kết quả của action họ vừa thực hiện
- Dữ liệu hiển thị phụ thuộc vào kết quả của server action

**Không cần revalidate khi**

- Form được ẩn sau khi submit (ví dụ: contact form)
- Dữ liệu không được hiển thị lại trên màn hình
- User được redirect sang trang khác sau action

**Ví dụ không cần revalidate**

```javascript
export async function submitContactForm(formData) {
  // Gửi email
  await sendEmail(formData);
  
  // Không cần revalidatePath vì form sẽ bị ẩn
  // hoặc user được redirect sang trang "Thank You"
}
```


### Best Practices

**Nguyên tắc chung**

- Luôn revalidate sau khi mutations (CREATE, UPDATE, DELETE)
- Chọn path revalidation hẹp nhất có thể
- Đặt `revalidatePath` sau khi confirm operation thành công
- Không revalidate nếu không cần thiết để tránh overhead

**Pattern thường gặp**

```javascript
export async function serverAction(formData) {
  // 1. Validate & authenticate
  // 2. Perform database operation
  // 3. Check for errors
  // 4. Revalidate if successful
  
  if (!error) {
    revalidatePath('/specific-path');
  }
}
```


### Import Đúng Package

**Lưu ý về import**

```javascript
// ĐÚNG
import { revalidatePath } from 'next/cache';

// SAI
import { revalidatePath } from 'next';
```

- Phải import từ `next/cache` package
- Đây là named import, cần dùng curly braces `{}`
- Nếu VS Code không tự động import, cần thêm thủ công


### Ghi Chú Thêm

**Tầm quan trọng của revalidation**

Revalidation là bước quan trọng trong flow của [[Server Actions]] để đảm bảo:

- UI luôn đồng bộ với server state
- User experience mượt mà
- Không cần hard reload để thấy thay đổi

**Debugging tip**

Nếu gặp lỗi import, kiểm tra:

- Package name: `next/cache`
- Syntax: named import với `{}`
- NextJS version có hỗ trợ function này

**Liên kết:** [[Server Actions]], [[Router Cache]], [[Dynamic Routes]], [[Cache Revalidation]], [[Supabase]], [[NextJS Cache]], [[On-demand Revalidation]]

