## Hydration trong Server-Side Rendering

### Tổng quan

Bài học này tiếp tục phần 2 của thí nghiệm xây dựng ứng dụng mini với kỹ thuật Server-Side Rendering (SSR). Phần này tập trung vào việc triển khai **hydration** để làm cho ứng dụng thực sự hoạt động với tính tương tác đầy đủ.

### Tạo file JavaScript cho Client

Sau khi đã có phần server, cần tạo file JavaScript chạy trên client để gắn vào HTML đã được render.

- Tạo file `client.js` với nội dung đơn giản ban đầu
- Thêm thẻ script vào HTML để tải file này

```javascript
// Trong file HTML
<script src="client.js"></script>
```

**Vấn đề gặp phải**: Khi tải trang, file `client.js` không được tải do server chưa có route xử lý yêu cầu này.

### Thiết lập Route cho Client.js

Để server có thể phục vụ file JavaScript, cần thêm route mới:

```javascript
// Đọc nội dung file client.js
const clientJS = fs.readFileSync('./client.js', 'utf-8');

// Tạo route xử lý yêu cầu
app.get('/client.js', (req, res) => {
  res.setHeader('Content-Type', 'application/javascript');
  res.send(clientJS);
});
```

**Lưu ý quan trọng**:

- Header phải là `application/javascript` thay vì `text/html`
- Trong thực tế, Next.js sử dụng bundler và các công cụ phức tạp hơn
- Code này chỉ để minh họa khái niệm, không phải cách làm trong production


### Thêm React và Babel vào Client

Client cần React và Babel để chạy JSX code:

```html
<!-- Thêm Babel từ CDN -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- Thêm React từ CDN -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

<!-- Client script với type="text/babel" -->
<script type="text/babel" src="client.js"></script>
```

**Tại sao cần các thư viện này**:

- Babel: Biên dịch JSX thành JavaScript hợp lệ
- React: Cung cấp các API cần thiết cho hydration
- ReactDOM: Cung cấp phương thức `hydrateRoot`


### Triển khai Hydration

Đây là bước quan trọng nhất - thay vì tạo React tree mới, ta "hydrate" (cấp nước) cho HTML đã có sẵn:

```javascript
// KHÔNG dùng createRoot như app thông thường
// createRoot(document.getElementById('root')).render(<Home />);

// Mà dùng hydrateRoot để hydrate HTML có sẵn
ReactDOM.hydrateRoot(
  document.getElementById('root'),
  <Home />
);
```

**Sự khác biệt giữa createRoot và hydrateRoot**:

- `createRoot`: Tạo React tree hoàn toàn mới, xóa bỏ HTML có sẵn
- `hydrateRoot`: Gắn event handlers và tính tương tác vào HTML đã được render từ server

**Điều kiện quan trọng**: React tree trên client phải giống hệt với tree được render trên server, nếu không sẽ có lỗi DOM hydration.

### Cấu trúc Code hoàn chỉnh

```javascript
// client.js
const pizzas = {
  margherita: { name: 'Margherita', price: 10 },
  pepperoni: { name: 'Pepperoni', price: 12 }
};

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(c => c + 1)}>
      {count}
    </button>
  );
}

function MenuItem({ pizza }) {
  return (
    <div>
      <h3>{pizza.name}</h3>
      <p>${pizza.price}</p>
      <Counter />
    </div>
  );
}

function Home() {
  return (
    <div>
      {Object.values(pizzas).map(pizza => (
        <MenuItem key={pizza.name} pizza={pizza} />
      ))}
    </div>
  );
}

// Hydrate thay vì render
ReactDOM.hydrateRoot(
  document.getElementById('root'),
  <Home />
);
```


### Kiểm tra Hydration với Throttling

Để quan sát rõ quá trình hydration, có thể sử dụng chế độ throttling mạng:

- Bật chế độ "Slow 3G" trong DevTools
- Reload trang
- Quan sát: HTML hiển thị ngay lập tức nhưng buttons chưa hoạt động
- Sau khi React tải xong, buttons bắt đầu hoạt động

**Lợi ích của SSR**:

- First Content Paint (FCP) nhanh hơn - người dùng thấy nội dung sớm
- Tính tương tác được thêm vào sau khi JavaScript tải xong
- Trải nghiệm người dùng tốt hơn trên mạng chậm


### Hai bước hoàn chỉnh của SSR

**Bước 1 - Server Side**:

- Sử dụng `renderToString()` để chuyển React components thành HTML string
- Gửi HTML này đến browser

**Bước 2 - Client Side**:

- Sử dụng `hydrateRoot()` để gắn event handlers và state management
- Làm cho ứng dụng trở nên tương tác


### So sánh với Frameworks thực tế

Thí nghiệm này giúp hiểu khái niệm, nhưng các framework như Next.js có nhiều ưu điểm hơn:

- Streaming content từng phần thay vì gửi toàn bộ HTML một lúc
- Tối ưu hóa bundle size
- Code splitting tự động
- Xử lý routing phức tạp
- Hỗ trợ nhiều chiến lược rendering (SSR, SSG, ISR)

**Kết luận**: Hiểu cách hydration hoạt động giúp nắm vững bản chất của SSR, nhưng trong thực tế nên sử dụng các framework đã được tối ưu hóa như Next.js.

***

**Liên kết thuật ngữ**: [[Server-Side Rendering]], [[Hydration]], [[ReactDOM]], [[renderToString]], [[hydrateRoot]], [[First Content Paint]], [[Next.js]], [[Babel]], [[CDN]], [[Bundle]], [[Event Handlers]], [[useState]], [[DOM]], [[JSX]]

