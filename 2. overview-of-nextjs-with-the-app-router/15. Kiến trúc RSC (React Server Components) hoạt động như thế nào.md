## Kiến trúc RSC (React Server Components) hoạt động như thế nào

Bài học này đi sâu vào cơ chế hoạt động của kiến trúc RSC phía sau hậu trường, giải thích chi tiết quá trình render và cách server components và client components tương tác với nhau.

### Ôn tập: Cách render trong React truyền thống

Trước khi tìm hiểu về RSC, cần nhớ lại cách React render trong môi trường không có server components:

- **Bước 1:** Viết các component (A, B, C)
- **Bước 2:** Tạo component tree (cây các component instance)
- **Bước 3:** Render component tree bằng cách gọi từng component function
- **Bước 4:** Kết quả là React element tree (Virtual DOM) - các JavaScript object chứa thông tin cần thiết để tạo DOM elements
- **Bước 5:** Commit Virtual DOM vào DOM thật, tạo ra HTML elements hiển thị trên màn hình


### Quá trình render trong kiến trúc RSC

Khi có cả server components (SC) và client components (CC) trong cùng một component tree, quá trình render được chia thành hai bước:

#### Bước 1: Render trên server

- **Render server components:** Tất cả server components được render trước trên server, tạo ra React elements
- **Đặc điểm quan trọng:** React elements này chỉ chứa output của server component, không còn chứa code gốc. Code đã "biến mất" trên server sau khi render
- **Lý do không dùng được state:** Đây là lý do kỹ thuật tại sao không thể dùng `useState` hoặc `useEffect` trong server components - các function này sẽ biến mất khi component được render, và toàn bộ kết quả phải serializable (có thể chuyển thành dữ liệu) để gửi đến client

**Xử lý client components trên server:**

- Client components không được render trên server
- Thay vào đó, tạo các "placeholder" (vị trí giữ chỗ) cho mỗi client component
- Mỗi placeholder chứa:
    - Serialized props được truyền từ server component (nếu có)
    - URL trỏ tới script chứa code của component
    - Thông tin này cần thiết để render client component sau này trên client

**Kết quả:** RSC Payload - cấu trúc dữ liệu đặc biệt chứa:

- Virtual DOM của tất cả server components (đã render)
- Sub-trees của client components chưa render (dưới dạng placeholders)

```javascript
// Ví dụ RSC Payload thực tế (dạng JSON-like)
// Dữ liệu được chia thành nhiều dòng để dễ streaming
M1:{"id":"./src/ClientButton.js","chunks":["client1"],"name":""}
S2:"react.suspense"
J0:["$","div",null,{"children":[
  ["$","h1",null,{"children":"Welcome"}],
  ["$","@1",null,{"text":"Click me"}]
]}]
```


#### Bước 2: Render trên client

- **Nhận RSC Payload:** Client nhận dữ liệu từ server
- **Render client components:** Các client components cuối cùng được render, tạo ra React elements mới
- **Hoàn thành Virtual DOM:** Có Virtual DOM đầy đủ trên client
- **Commit vào DOM:** Quy trình giống React truyền thống


### Tại sao cần RSC Payload thay vì HTML?

Lý do cốt lõi React luôn muốn mô tả UI dưới dạng **data** (dữ liệu) thay vì HTML đã hoàn chỉnh:

- **Bảo toàn UI state:** Khi server component re-render và tạo React element mới, element này có thể merge một cách liền mạch vào Virtual DOM hiện có trên client
- **Reconciliation:** React có thể reconcile (đối chiếu) cây mới từ server với cây hiện tại trên client, giữ nguyên UI state
- **Tránh mất state:** Nếu chỉ gửi HTML, toàn bộ UI phải được thay thế, mất hết state hiện tại, gây trải nghiệm người dùng kém


### So sánh: React truyền thống vs RSC

**React truyền thống:**

```
Component Tree → Virtual DOM → Real DOM → DOM Elements
```

**React với RSC:**

```
Component Tree (Server + Client)
  ↓ Bước 1 (trên server)
RSC Payload (Server components rendered + Client placeholders)
  ↓ Streaming đến client
  ↓ Bước 2 (trên client)
Complete Virtual DOM → Real DOM → DOM Elements
```


### Đặc điểm kỹ thuật quan trọng

- **Non-blocking process:** Các bước không block (chặn) nhau. Kết quả render trên server được stream ngay đến client và tích hợp liền mạch theo thời gian
- **UI as function:** Về mặt kỹ thuật chính xác, UI không phải là function của cả data và state cùng lúc. Thay vào đó:
    - UI = function(data) → trả về function
    - Kết quả = function(state)
    - Hay: `UI = f(data)(state)`


### Lợi ích của kiến trúc hai bước

- **Tách biệt môi trường:** Server xử lý data fetching và logic phức tạp, client xử lý interactivity
- **Streaming:** Cải thiện hiệu suất bằng cách gửi dữ liệu dần dần
- **State preservation:** Giữ nguyên trạng thái UI khi re-render
- **Code splitting tự động:** Client chỉ tải code cần thiết cho client components


### Ghi chú thêm

- RSC Payload sử dụng format tương tự JSON nhưng được tối ưu cho streaming
- Bundler (như Webpack, Turbopack) đóng vai trò quan trọng trong việc tạo script URLs và xử lý code splitting
- Không thể tự implement RSC mà không có framework vì độ phức tạp của bundler và streaming mechanism
- "React Server" và "React Client" không giống với "Web Server" và "Browser" trong nghĩa truyền thống

**Liên kết:** [[RSC Payload]], [[Server Components]], [[Client Components]], [[Virtual DOM]], [[Reconciliation]], [[Streaming]], [[Serialization]]

***

Bạn muốn tìm hiểu thêm về mối quan hệ giữa RSC và Server-Side Rendering (SSR) không?

